---
layout: single
title: 🤖 AI가 레거시 시스템 고도화에서 기대만큼 성능을 내지 어려운 이유
categories: systemdesign
tag: [systemdesign]
toc: true
---

## 🚀 1. 배경

최근 "AI가 10명 중 8명의 개발자를 대체할 것"이라는 말을 자주 듣는다. 실제로 AI가 신규 개발에서 엄청난 생산성 향상을 가져다주는 것은 부정할 수 없는 사실이다. 간단한 CRUD API 구현, 프론트엔드 컴포넌트 생성, 유틸리티 함수 작성 등에서 AI의 도움으로 개발 속도가 비약적으로 향상되었다. 이런 측면에서 "반복적이고 구조화된 업무의 생산성을 크게 높일 수 있다"는 주장은 충분히 체감되고 동의할 만하다.

하지만 여기서 중요한 점을 놓치고 있다. 개발이라는 행위는 분명 구조화된 결과물을 만들어내지만, 그 과정 자체가 반복적이고 구조화된 것은 아니다. 매번 새로운 문제 상황에 직면하고, 예상치 못한 제약 조건들을 해결해야 하며, 기존 시스템과의 복잡한 상호작용을 고려해야 한다. 특히 레거시 시스템을 다룰 때는 더욱 그렇다.

---

## 💰 2. 요금제별 권장 코드라인을 통한 AI 도구 분석

많은 개발자들이 AI를 통해 레거시 시스템의 획기적인 개선을 기대한다. 하지만 현실은 어떨까? 

클로드 코드(Claude Code)의 가격정책을 살펴보면 흥미로운 사실을 발견할 수 있다. 프로 플랜은 월 20달러로 1,000줄 이하의 작은 저장소에서 가벼운 코딩 작업에 적합하다고 명시되어 있다. 월 100달러인 맥스 플랜은 5배 더 많은 사용량을, 200달러 플랜은 20배의 사용량을 제공한다.

### 🧮 1) 실제 토큰 소모와 비용 계산

여기서 더 깊이 들어가보자. 실제로 코드 1라인은 대략 5~10토큰 정도를 소모한다. 언어나 주석의 양에 따라 달라지지만, 대략적인 계산을 해보면:

- 1,000라인 코드 ≈ 5,000~10,000토큰
- 10,000라인 코드 ≈ 50,000~100,000토큰

모델별 토큰 가격을 보면:
- **Opus 4**: 입력 $15/100만 토큰, 출력 $75/100만 토큰
- **Sonnet 4**: 입력 $3/100만 토큰, 출력 $15/100만 토큰

10,000라인의 코드를 분석하고 생성한다고 가정하면:
- Sonnet 4 기준: 약 $0.9~$1.5
- Opus 4 기준: 약 $4.5~$7.5

### 😅 2) 단순 비교의 함정

여기서 잠깐! 이런 단순 비교가 과연 공정할까? 사실 코드 작성과 이해는 사용하는 모델, 코드의 복잡도, 프로그래밍 언어 등에 따라 천차만별의 결과를 보인다. 게다가 세션은 5시간 단위로 유지되고, 세션 종료 시 대화 맥락이 초기화된다는 점도 고려해야 한다.

이런 식의 라인 수 기반 비교는 마치 "자동차 연비를 바퀴 개수로 계산하는 것"만큼이나 비효율적일 수 있다. 

솔직히 말하자면, 이런 다소 단순한 비교를 시도한 이유가 있다. 단순한 비교로 인한 결과가 비효율적인 것만큼 "반복적이고 구조화된 업무의 생산성"이라는 말이 마치 개발의 전부인 것으로 측정하는 것 또한 비효율적일 수 있다는 말이다.

결국 1,000줄이라는 "권장" 수치가 시사하는 바는 명확하다. AI 도구들이 아직은 상대적으로 작은 규모에서만 효과적으로 작동한다는 것이다. 레거시 시스템을 전면 개선하려면 월 수백 달러에서 수천 달러의 AI 비용이 발생할 수도 있다는 계산이 나온다. 물론 이것도 AI가 대규모 코드베이스를 완벽하게 이해한다는 가정 하에서 말이다.
---

## 📊 3. 실제 사례로 보는 AI의 한계

최근 연구 자료들을 살펴보면 AI가 레거시 시스템 고도화에서 겪는 구체적인 한계들이 명확하게 드러난다.

### 📉 1) 복잡성에 따른 성능 저하

Apple의 2025년 6월 연구에 따르면, 대형 추론 모델(LRMs)들은 문제의 복잡성이 증가할수록 "완전한 정확도 붕괴"를 경험한다고 한다. Google의 Gemini Thinking, OpenAI의 o3, Claude 3.7 Sonnet-Thinking 등 주요 AI 모델들이 모두 이런 패턴을 보였다.

특히 흥미로운 점은 AI 모델들이 정확도 붕괴 지점에 접근할수록 추론 노력을 줄이기 시작한다는 것이다. 이는 레거시 시스템처럼 복잡하고 상호 의존적인 코드베이스에서는 AI가 오히려 비효율적으로 작동할 수 있음을 시사한다.

### 📏 2) 레거시 시스템의 실제 규모

레거시 시스템의 실제 규모를 이해하려면 구체적인 사례를 살펴볼 필요가 있다. 필자가 관리했던 3천 명 정도가 사용하는 HR 시스템의 경우, Java, XML, JSP, JavaScript, CSS, HTML, SQL, Properties 파일을 모두 합쳐 약 580만 줄에 달했다. 영업 시스템은 약 30만 줄이었지만, 이는 외부 인터페이스와 배치 시스템이 누락된 수치였다.

더 중요한 것은 주요 비즈니스 로직이 PL/SQL로 작동한다는 점이다. 많은 레거시 시스템들이 Oracle 데이터베이스의 스토어드 프로시저에 핵심 비즈니스 로직을 구현해 놓고 있다. 이런 환경에서 AI가 제공하는 1,000줄 단위의 코드 개선이 얼마나 제한적인지 쉽게 알 수 있다.

### 🔧 3) 기술적 장벽

현재 대부분의 AI 코딩 도구들은 Python, JavaScript, Java 등 현대적인 프로그래밍 언어에 최적화되어 있다. PL/SQL에 대한 AI의 이해도는 상대적으로 낮으며, 특히 Oracle 데이터베이스의 고유한 기능들과 복잡한 스토어드 프로시저를 분석하고 개선하는 능력은 제한적이다.

오래된 시스템들은 시스템 간 연동을 고려하지 않고 설계되어 데이터가 분산되어 있다. AI가 효과적으로 작동하려면 대량의 데이터가 필요한데, 서로 다른 데이터 형식과 구조를 가진 시스템들을 통합하는 것은 복잡한 작업이다. 또한 기존 시스템들은 AI가 요구하는 실시간 분석이나 대규모 자동화를 처리할 수 있는 처리 능력과 확장성이 부족하다.

### 🏗️ 4) 모놀리식 아키텍처의 복잡성

현대의 마이크로서비스 아키텍처(MSA)는 일반적으로 한두 개의 명확한 도메인을 담당하도록 설계된다. 주문 서비스는 주문만, 결제 서비스는 결제만 처리하는 식이다. 하지만 레거시 시스템은 전혀 다른 양상을 보인다.

대부분의 레거시 시스템은 수십 개의 서로 다른 비즈니스 도메인이 하나의 거대한 애플리케이션 안에 얽혀있다. 전통적인 ERP 시스템 하나에는 인사관리, 재무회계, 영업관리, 구매조달, 생산관리 등이 모두 들어있다.

더 큰 문제는 이런 도메인들 사이의 경계가 명확하지 않다는 것이다. 급여 계산 로직이 인사 테이블, 회계 테이블, 생산 실적 테이블을 동시에 참조하는 경우가 흔하다. 한 번의 급여 처리를 위해 시스템 전반의 데이터와 로직이 복합적으로 작용한다.

AI가 이런 복잡한 도메인 간 의존성을 완전히 이해하고 개선안을 제시하기는 매우 어렵다. 코드의 구문적 연관성은 파악할 수 있지만, 비즈니스적 맥락에서의 의미적 연관성을 이해하는 데는 한계가 있기 때문이다.

---

## 💡 4. 결론: 생산성이라는 단어의 함정

AI는 분명히 강력한 도구다. 신규 개발에서 보여주는 생산성 향상은 놀라울 정도이며, 이는 개발자들의 일하는 방식을 근본적으로 바꾸고 있다. 하지만 레거시 시스템의 고도화에서는 우리가 기대하는 만큼의 혁신적 성능을 보여주지 못하고 있다.

그런데 여기서 잠깐, 우리가 말하는 "생산성 향상"이란 정확히 무엇을 의미하는 걸까?

많은 사람들이 생산성을 "단순히 공수를 줄이는 것"으로 이해한다. 코드를 빨리 작성하고, 기능을 빠르게 구현하고, 마감일을 맞추는 것. AI가 탁월한 성과를 보이는 것도 바로 이런 영역이다. 명확한 요구사항이 있고, 정해진 패턴이 있으며, 즉각적인 결과물이 필요한 작업들 말이다.

하지만 레거시 시스템을 다루면서 깨달은 것이 있다. 개발의 진정한 생산성은 단순 공수 감소가 아니다. 오히려:
- 6개월 후 바뀔 수 있는 정책을 예상하며 확장 포인트를 설계하는 것
- 다른 시스템과의 연동을 고려하며 인터페이스를 정의하는 것
- 팀원들이 이해하고 수정하기 쉬운 코드 구조를 고민하는 것
- 성능, 보안, 유지보수성 사이의 트레이드오프를 결정하는 것

아이러니하게도, "공수를 줄여서 빨리 끝내는 것"이 오히려 더 반복적이고 구조화된 행동이다. 반면, "주변 환경과 미래를 고려하며 신중하게 설계하는 것"은 매번 다른 맥락과 조건을 고려해야 하는 창의적이고 비구조화된 활동이다.

레거시 시스템이 AI에게 어려운 이유도 여기에 있다. 복잡성에 따른 성능 저하, 높은 비용, 기술적 제약 등도 문제지만, 더 근본적으로는 AI가 잘하는 "반복적이고 구조화된 작업"과 레거시 시스템 고도화가 요구하는 "창의적이고 맥락적인 판단" 사이의 간극이 존재한다.

결국 개발의 본질은 "빨리 만드는 것"이 아니라 "제대로 만드는 것"이다. 그리고 "제대로"의 정의는 매번 달라진다. 이것이 AI가 아직 완전히 이해하지 못하는, 그리고 앞으로도 쉽게 대체하기 어려운 개발자의 진짜 가치다.

AI를 "마법의 지팡이"가 아닌 "유용한 도구 중 하나"로 접근할 때, 우리는 비로소 진정한 생산성 향상을 이룰 수 있을 것이다.

---

## 📖 5. 참고자료
- [From Maintenance to Innovation: Generative AI in the Evolution of Legacy Applications](https://insights.daffodilsw.com/blog/from-maintenance-to-innovation-generative-ai-in-the-evolution-of-legacy-applications)
- [Integrating Legacy Systems with AI: The Technical and Strategic Hurdles](https://www.getstellar.ai/blog/integrating-legacy-systems-with-ai-the-technical-and-strategic-hurdles)
- [The Potential and Limitations of AI in Software Development](https://www.toolify.ai/ai-news/the-potential-and-limitations-of-ai-in-software-development-892265)
- [AI Models: Critical Limitations in Complex Problem-Solving Revealed by Apple Study](https://www.businesstechweekly.com/technology-news/ai-models-critical-limitations-in-complex-problem-solving-revealed-by-apple-study/)
- [Norris Numbers - 프로그래밍 복잡성에 대한 재미있는 관찰](https://www.teamten.com/lawrence/writings/norris-numbers.html)
- [Using Claude Code with your Pro or Max plan](https://support.anthropic.com/en/articles/11145838-using-claude-code-with-your-pro-or-max-plan)

---

## 🤝 6. 맺으며: 개발자라는 정체성에 대한 고민

10년 넘게 개발로 밥벌어 먹고 살면서도, 나는 스스로를 '개발자'라고 부르기를 주저해왔다. 개발자란 무엇인가에 대한 명확한 정의를 내릴 수 없었기 때문이다.

하지만 시간이 지나면서 어렴풋이 깨달은 것이 있다. 개발자는 단순히 코드를 작성하는 사람이 아니라, "요구사항을 이해하고 무언가를 만들어낼 수 있는 사람"이라는 것. 추상적이지만, 이 능력이야말로 개발자의 본질이 아닐까 추측하고 있다.

최근 빅테크 기업들이 뛰어난 개발자들을 대량으로 구조조정하는 모습을 보며 많은 생각이 들었다. 이것이 개발자들의 능력 부족 때문일까? 아니다. 오히려 그들이 너무나 훌륭하게 시스템을 구축하고, 프로세스를 자동화하고, 관리 가능한 구조를 만들어냈기 때문에 가능한 일이라고 생각한다. 역설적이게도, 그러한 완성된 환경이 그곳에서는 개발이라는 행위가 대체가능한 수준으로 만들어졌다고 생각한다.

하지만 "무언가를 만들어낼 수 있는" 그 창조적 능력과 관리 능력까지 대체될 수 있을까? 나는 그렇게 생각하지 않는다. AI가 아무리 발전해도, 불확실한 요구사항을 해석하고, 맥락을 이해하며, 없던 것을 만들어내는, 그리고 그것을 관리하는 그 능력은 여전히 인간 개발자의 영역으로 남을 것이다.
