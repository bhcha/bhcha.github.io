---
layout: single
title: 🤖 AI가 레거시 시스템 고도화에서 기대만큼 성능을 내지 못하는 이유
categories: systemdesign
tag: [systemdesign]
toc: true
---

## 🚀 1. 배경

최근 "AI가 10명 중 8명의 개발자를 대체할 것"이라는 말을 자주 듣는다. 실제로 AI가 신규 개발에서 엄청난 생산성 향상을 가져다주는 것은 부정할 수 없는 사실이다. 간단한 CRUD API 구현, 프론트엔드 컴포넌트 생성, 유틸리티 함수 작성 등에서 AI의 도움으로 개발 속도가 비약적으로 향상되었다. 이런 측면에서 "반복적이고 구조화된 업무의 생산성을 크게 높일 수 있다"는 주장은 충분히 체감되고 동의할 만하다.

하지만 여기서 중요한 점을 놓치고 있다. 개발이라는 행위는 분명 구조화된 결과물을 만들어내지만, 그 과정 자체가 반복적이고 구조화된 것은 아니다. 매번 새로운 문제 상황에 직면하고, 예상치 못한 제약 조건들을 해결해야 하며, 기존 시스템과의 복잡한 상호작용을 고려해야 한다. 특히 레거시 시스템을 다룰 때는 더욱 그렇다.

---

## 💰 2. 레거시 시스템에서 AI 활용의 실제 비용 분석

### 🧮 1) 실제 토큰 소모와 비용 계산

클로드 코드(Claude Code)의 가격정책을 통해 구체적인 비용을 살펴보면, 프로 플랜은 월 20달러로 1,000줄 이하의 작은 저장소에서 가벼운 코딩 작업에 적합하다고 명시되어 있다.

실제로 코드 1라인은 대략 5~10토큰 정도를 소모한다. 레거시 시스템의 규모를 고려한 비용을 계산해보면:

**중소규모 레거시 시스템 (30만 라인)**
- 토큰 수: 1,500,000~3,000,000 토큰
- Sonnet 4 기준: 약 $27~$54 (입력 + 출력)
- Opus 4 기준: 약 $135~$270 (입력 + 출력)

**대규모 레거시 시스템 (100만 라인)**
- 토큰 수: 5,000,000~10,000,000 토큰
- Sonnet 4 기준: 약 $90~$180 (입력 + 출력)
- Opus 4 기준: 약 $450~$900 (입력 + 출력)

**엔터프라이즈 레거시 시스템 (580만 라인 - 실제 HR 시스템 사례)**
- 토큰 수: 29,000,000~58,000,000 토큰
- Sonnet 4 기준: 약 $522~$1,044 (입력 + 출력)
- Opus 4 기준: 약 $2,610~$5,220 (입력 + 출력)

이는 단순히 코드를 한 번 읽고 분석하는 비용이다. 실제 개발 과정에서는 반복적인 분석과 수정이 필요하므로, 월간 비용은 수천에서 수만 달러에 이를 수 있다.

### 📊 2) 컨텍스트 윈도우의 한계

더 큰 문제는 비용만이 아니다. 대부분의 AI 모델은 컨텍스트 윈도우 제한이 있다:
- Claude 3.5: 200K 토큰 (약 20,000~40,000 라인)
- GPT-4: 128K 토큰 (약 12,800~25,600 라인)

580만 라인의 시스템을 분석하려면 최소 145~290번의 별도 세션이 필요하며, 각 세션 간의 맥락은 유지되지 않는다.

---

## 📈 3. 리팩토링된 코드 vs 레거시 코드의 생산성 차이

### 🔨 1) Claude의 대규모 리팩토링 성공 사례

Anthropic의 보고서에 따르면, Claude는 10,000줄 이상의 대규모 리팩토링 프로젝트에서 주목할 만한 성과를 보였다. 특히 잘 구조화된 현대적 코드베이스에서는:
- 코드 중복 제거: 30% 감소
- 함수 복잡도 개선: 평균 15% 감소
- 테스트 커버리지 증가: 25% 향상

### 📉 2) 레거시 시스템에서의 생산성 격차

하지만 레거시 시스템에서는 완전히 다른 양상을 보인다:

**리팩토링된 현대적 코드베이스**
- AI 지원 개발 생산성: 200~300% 향상
- 코드 이해 시간: 70% 단축
- 버그 발생률: 40% 감소

**리팩토링되지 않은 레거시 시스템**
- AI 지원 개발 생산성: 20~50% 향상
- 코드 이해 시간: 30% 단축
- 버그 발생률: 10% 감소 (때로는 증가)

이러한 차이가 발생하는 주요 원인은:
1. **명확한 도메인 경계**: 현대적 아키텍처는 마이크로서비스나 모듈로 명확히 분리되어 있다
2. **일관된 코딩 컨벤션**: 레거시 시스템은 수십 년간 여러 개발자의 서로 다른 스타일이 혼재한다
3. **문서화 수준**: 리팩토링 과정에서 문서화가 개선되어 AI가 맥락을 이해하기 쉽다
4. **기술 스택의 현대성**: AI는 최신 프레임워크와 패턴에 더 익숙하다

### 💡 3) AI 도구의 실제 활용 패턴

레거시 시스템에서 AI를 활용할 때 나타나는 일반적인 패턴:

**직접 적용의 한계**
- 복잡한 비즈니스 로직을 AI가 완전히 이해하기 어렵다
- 문서화되지 않은 암묵적 규칙들이 코드 곳곳에 숨어있다
- 데이터베이스 레벨의 제약사항이 애플리케이션 코드에 명시되지 않는다

**점진적 개선 접근법**
- 작은 유틸리티 함수부터 시작하여 점차 복잡한 모듈로 확대
- 테스트 코드가 있는 부분을 우선적으로 개선
- AI가 생성한 코드를 반드시 도메인 전문가가 검증

**실무에서 관찰되는 효과**
- 단순 CRUD 작업: 150-200% 생산성 향상
- 복잡한 비즈니스 로직: 20-30% 생산성 향상
- 레거시 통합 작업: 10% 미만 또는 오히려 지연 발생

---

## 📊 4. 실제 사례로 보는 AI의 한계

### 📉 1) 복잡성에 따른 성능 저하

Apple의 2025년 6월 연구에 따르면, 대형 추론 모델(LRMs)들은 문제의 복잡성이 증가할수록 "완전한 정확도 붕괴"를 경험한다고 한다. 특히 흥미로운 점은 AI 모델들이 정확도 붕괴 지점에 접근할수록 추론 노력을 줄이기 시작한다는 것이다.

### 📏 2) 레거시 시스템의 실제 규모와 복잡성

레거시 시스템의 복잡성은 단순한 코드 라인 수로 측정할 수 없다:

**복잡도 증폭 요인들**
- **순환 복잡도(Cyclomatic Complexity)**: 레거시 시스템의 주요 함수들은 평균 50~100의 순환 복잡도를 가진다 (권장값: 10 이하)
- **결합도(Coupling)**: 평균적으로 하나의 모듈이 20~30개의 다른 모듈과 직접 연결되어 있다
- **응집도(Cohesion)**: 단일 책임 원칙을 위반하는 "신(God) 클래스"들이 수천 라인에 달한다

### 🔧 3) 기술적 장벽과 도메인 특수성

**PL/SQL과 스토어드 프로시저의 문제**
- AI의 PL/SQL 이해도: Java/Python 대비 30% 수준
- 복잡한 비즈니스 로직이 DB 레벨에 구현되어 있어 애플리케이션 코드만으로는 전체 로직 파악 불가
- 트랜잭션 경계와 데이터 무결성 제약이 코드가 아닌 DB 설정에 의존

**레거시 시스템의 숨겨진 의존성**
```sql
-- 예시: 급여 계산 스토어드 프로시저
CREATE PROCEDURE CALC_SALARY AS
BEGIN
  -- 200줄의 복잡한 로직
  -- 15개 테이블 조인
  -- 회사별 특수 규칙 50개 이상
  -- 법적 요구사항 반영
  -- 10년치 예외 처리 누적
END;
```

이런 프로시저 하나를 이해하고 개선하려면 도메인 지식, 법적 요구사항, 역사적 맥락을 모두 파악해야 한다.

---

## 💡 5. 결론: AI와 레거시 시스템의 현실적 접근법

### 🎯 1) 단계적 접근 전략

AI를 레거시 시스템에 효과적으로 활용하려면:

1. **부분적 리팩토링 우선**: 핵심 모듈부터 현대적 구조로 개선
2. **도메인 경계 명확화**: 비즈니스 로직을 명확한 서비스로 분리
3. **점진적 AI 도입**: 리팩토링된 부분부터 AI 활용도 높이기

### 💭 2) 생산성의 재정의

진정한 생산성은 "빨리 만드는 것"이 아니라 "지속 가능하게 만드는 것"이다:

- **단기 생산성**: 코드 작성 속도 (AI가 탁월)
- **장기 생산성**: 유지보수성, 확장성, 안정성 (인간의 판단력 필요)

### 🔮 3) AI 시대 개발자의 역할

AI는 "마법의 지팡이"가 아닌 "강력한 도구"다. 레거시 시스템을 다루는 개발자는:
- 비즈니스 맥락을 이해하고 AI에게 올바른 방향을 제시하는 설계자
- 복잡한 의존성을 파악하고 단순화하는 아키텍트
- AI가 생성한 코드의 타당성을 검증하는 품질 관리자

결국 AI 시대에도 레거시 시스템의 고도화는 인간의 통찰력과 AI의 생산성이 조화를 이룰 때 성공할 수 있다.

---

## 📖 6. 참고자료
- [From Maintenance to Innovation: Generative AI in the Evolution of Legacy Applications](https://insights.daffodilsw.com/blog/from-maintenance-to-innovation-generative-ai-in-the-evolution-of-legacy-applications)
- [Integrating Legacy Systems with AI: The Technical and Strategic Hurdles](https://www.getstellar.ai/blog/integrating-legacy-systems-with-ai-the-technical-and-strategic-hurdles)
- [The Potential and Limitations of AI in Software Development](https://www.toolify.ai/ai-news/the-potential-and-limitations-of-ai-in-software-development-892265)
- [AI Models: Critical Limitations in Complex Problem-Solving Revealed by Apple Study](https://www.businesstechweekly.com/technology-news/ai-models-critical-limitations-in-complex-problem-solving-revealed-by-apple-study/)
- [Claude's Large-Scale Refactoring Capabilities](https://apidog.com/kr/blog/claude-md-kr/)
- [Using Claude Code with your Pro or Max plan](https://support.anthropic.com/en/articles/11145838-using-claude-code-with-your-pro-or-max-plan)

---

## 🤝 7. 맺으며: 개발자라는 정체성에 대한 고민

10년 넘게 개발로 밥벌어 먹고 살면서도, 나는 스스로를 진정한 '개발자'라고 부르기를 주저해왔다. 개발자란 무엇인가에 대한 명확한 정의를 내릴 수 없었기 때문이다.

하지만 시간이 지나면서 어렴풋이 깨달은 것이 있다. 개발자는 단순히 코드를 작성하는 사람이 아니라, "요구사항을 이해하고 무언가를 만들어낼 수 있는 사람"이라는 것. 추상적이지만, 이 능력이야말로 개발자의 본질이 아닐까.

최근 빅테크 기업들이 뛰어난 개발자들을 대량으로 구조조정하는 모습을 보며 많은 생각이 들었다. 이것이 개발자들의 능력 부족 때문일까? 아니다. 오히려 그들이 너무나 훌륭하게 시스템을 구축하고, 프로세스를 자동화하고, 관리 가능한 구조를 만들어냈기 때문에 가능한 일이라고 생각한다. 역설적이게도, 개발자들의 성공이 그들 자신을 대체 가능하게 만든 것이다.

하지만 잠깐, 이들이 만들어낸 것이 무엇인지 생각해보자. 불모지에서 시작해 복잡한 비즈니스 로직을 코드로 구현하고, 수백만 사용자가 안정적으로 사용할 수 있는 시스템을 구축하고, 끊임없이 변화하는 요구사항에 대응할 수 있는 유연한 구조를 설계했다. 이런 "무언가를 만들어내는" 창조적 능력까지 정말 대체될 수 있을까?

나는 그렇게 생각하지 않는다. AI가 기존의 패턴을 학습하고 재현하는 것은 탁월하지만, 아무것도 없는 곳에서 시작해 불확실한 요구사항을 해석하고, 복잡한 맥락을 이해하며, 전에 없던 해결책을 만들어내는 것은 다른 차원의 능력이다. 그리고 이것이야말로 개발자들이 지금까지 해왔고, 앞으로도 계속 해야 할 일이다.

결국 AI 시대의 개발자는 "코드를 작성하는 사람"에서 "문제를 정의하고 해결책을 설계하는 사람"으로 진화해야 할지도 모른다. 그리고 그것이 어쩌면 진정한 개발자의 모습일 것이다.