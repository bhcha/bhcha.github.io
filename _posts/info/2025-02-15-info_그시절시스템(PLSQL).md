---
layout: single
title: 201x년도 시스템 - PLSQL
categories: info
tag: [그때그시절]
toc: true
#author_profile: false
#sidebar:
#    nav: "docs"
---

## 과거 기업용 시스템

과거 기업용 시스템(기간계 시스템, 레거시 시스템 등)의 소스 코드들을 살펴보면, 특정한 구조적 패턴이 반복적으로 등장하는 것을 볼 수 있다. 이는 개발 당시의 환경과 요구사항에 의해 결정된 것이며, 기술의 발전과 함께 점차 변화해왔다.

> 당연히 기업별 차이가 존재하며, 이는 개인적인 경험을 기반으로 한 관찰이므로 절대적인 신뢰성을 보장할 수는 없다.

## PLSQL(Procedure, Oracle Package 등)의 전성기

현재는 많이 사용되지 않지만, 과거에는 PLSQL이 기업용 시스템 개발에서 광범위하게 활용되었다. 흔히 JPA와 같은 현대적인 ORM 기술이 없었기 때문이라고도 하지만, 보다 근본적인 이유가 존재한다고 본다.

### 1. 무중단 운영관리

DevOps 문화가 확산된 현대에는 무중단 배포(Zero Downtime Deployment)와 지속적 통합(Continuous Integration), 지속적 배포(Continuous Deployment)가 당연한 개념이 되었다. 하지만 과거에는 무중단 운영이라는 개념 자체가 대중적이지 않았으며, 이를 실현하기 위한 기술적 방법도 현재만큼 정립되지 않았다.

> 실제로 무중단 배포와 CI/CD 개념은 2000년대 초반부터 존재했으나, 국내 기업용 시스템에는 2010년대 후반부터 점진적으로 적용되었으며, 많은 기업들은 코로나 시기를 기점으로 본격적으로 도입하기 시작했다.

이러한 상황에서, 무중단 운영이 불가능한 시스템을 “무중단에 가깝게” 운영할 수 있도록 하기 위한 해결책으로 PLSQL이 적극적으로 활용되었다.

PLSQL을 통한 무중단 운영의 실현

기업 시스템에서는 다음과 같은 요구사항이 있었다.
1.	**운영 중인 시스템을 중단 없이 데이터 모델 및 비즈니스 로직을 변경할 필요가 있음**
-	배포를 위한 서버 재시작이 어려웠고, 배포 프로세스 자체가 길었음.
-	한 번 배포하는 데 시간이 오래 걸리며, 문제가 발생하면 복구도 쉽지 않음.
2.	**DB 내에서 직접 데이터 조작이 가능해야 함**
-	많은 기업 시스템이 업무 로직을 DB 내에서 직접 처리하는 구조였음.
-	서버 애플리케이션이 아니라 DB 트리거, 스토어드 프로시저(Stored Procedure), 패키지(Package) 등을 활용하여 비즈니스 로직을 처리.
3.	**즉시 반영과 운영 안정성**
-	DB 내에서 로직을 수정하면, 서버 배포 없이도 로직을 변경할 수 있었음.
-	운영 중인 애플리케이션에 영향을 주지 않으면서, 데이터 처리 로직을 수정할 수 있었음.


### 2. 돈

위 내용에서 언급한 것처럼, 왜 비즈니스 로직을 백엔드 단에서 구현하지 않고 DB에 직접 구현했을까? 결국 비용 문제라고 생각한다.

#### 1) DB 중심 개발이 인건비 절감에 유리했다

그 당시의 시장을 보면, SQL을 다루는 인력(쿼리 개발자, DBA, PL/SQL 개발자)의 인건비가 상대적으로 낮았다.
특히, 일반적인 애플리케이션 개발자(Java, C, C++ 등)보다도 DB 스크립트를 작성할 수 있는 인력의 공급이 많고, 상대적으로 저렴했다.
-	기업 입장에서는 저렴한 인력을 활용하여 시스템을 유지보수하는 것이 가능했다.
-	복잡한 백엔드 애플리케이션을 개발하기보다, DB 내부에서 프로시저와 트리거로 로직을 처리하는 것이 비용 절감에 효과적이었다.

#### 2) 러닝 커브(학습 비용) 문제

PLSQL을 포함한 데이터베이스 기반 개발은 프로그래밍 언어(JAVA, C# 등)보다 상대적으로 배우기 쉬웠다.
-	백엔드 개발을 위해 객체지향 프로그래밍(OOP)을 깊게 이해하는 것보다, SQL과 PLSQL 문법을 익히는 것이 훨씬 러닝 커브가 낮았다.
-	DBA 및 PLSQL 개발자는 특정 기능에 집중할 수 있었고, 프로그래밍 언어를 배우지 않고도 중요한 시스템을 다룰 수 있었다.

결국, 기업 입장에서 백엔드 개발자를 고용하는 비용보다 DB 중심의 개발자가 더 저렴했고, 유지보수도 쉬웠기 때문에 DB 내에서 로직을 구현하는 것이 합리적인 선택이었다.

---

지금 개발을 시작하는 분들은 이러한 구조를 처음 접했을 때 쉽게 이해하기 어려울 수 있다. 왜 비즈니스 로직이 DB에 집중되었는지, 왜 이런 방식이 선택되었는지 현재의 개발 패러다임만으로는 설명하기 어려운 부분이 많다. 하지만, 당시의 기술적 한계, 비용 절감, 운영 환경을 고려해 본다면 이러한 선택이 나름의 이유와 맥락을 가지고 있었다는 점을 이해할 수 있을 것이다.

개발 환경은 계속 변화하고 있으며, 과거의 방식이 지금과 다르다고 해서 무조건 잘못된 것이라고 단정 짓기보다, 왜 그런 방식이 주류였는지를 이해하는 것이 중요하다.
그렇게 하면 단순히 “이전 기술이 구식이다”라고 평가하는 것이 아니라, 기술이 발전해온 과정과 그 이유를 더 깊이 이해할 수 있는 시각을 가질 수 있다.

격세지감을 느낄 수도 있겠지만, 이러한 변화는 결국 더 나은 개발 환경과 아키텍처로 나아가기 위한 과정이다. 과거의 선택을 돌아보며, 현재와 미래의 기술을 어떻게 적용할지 고민하는 것이 개발자로서 더 중요한 태도가 아닐까?

> 이전 PLSQL로 비즈니스 프로세스가 구축된 솔루션 기반 회사에서 JPA를 검토했던 이유는 영속성 관리 등의 이유가 아니라, 다양한 DB에 상대적으로 큰 변경 없이 적용할 수 있다는 점 때문이었던 적도 있다.